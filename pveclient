#!/usr/bin/perl

use strict;
use warnings;
use Cwd 'abs_path';
use lib '/usr/share/pve-client';
use lib '.';
use Data::Dumper;

use PVE::JSONSchema;
use PVE::CLIHandler;

use PVE::APIClient::LWP;
use PVE::APIClient::Helpers;
use PVE::APIClient::Commands::remote;
use PVE::APIClient::Commands::lxc;

use JSON;

sub print_usage {

    my $text = "pveclient usage:\n\n";

    $text .= "pveclient remote <help|add|remove> {options}\n\n";

    $text .= "pveclient lxc <help|create|destroy|...> {options}\n\n";

    $text .= "pveclient <get/set/create/delete> <path> {options}\n\n";

    print STDERR $text;

}

sub call_method {
    my ($path, $method, $args) = @_;

    die "missing API path\n" if !defined($path);

    my $info = PVE::APIClient::Helpers::lookup_api_method($path, $method);
    my $param = PVE::JSONSchema::get_options($info->{parameters}, $args);
    print Dumper($param);

    die "implement me";
}

# NOTE: This binary is just a placeholer - nothing implemented so far!

#my $hostname = 'localhost';
#my $username = 'root@pam';
#
#my $conn = PVE::APIClient::LWP->new(
#    username => $username,
#    #password => 'yourpassword',
#    #ticket => $ticket,
#    #csrftoken => $csrftoken,
#    host => $hostname,
#    # allow manual fingerprint verification
#    manual_verification => 1,
#    );

#my $res = $conn->get("/", {});
#print to_json($res, { pretty => 1, canonical => 1});

my $cli_class_handlers = {
    lxc => 'PVE::APIClient::Commands::lxc',
    remote => 'PVE::APIClient::Commands::remote',
};

my $cmd = shift || (print_usage() && exit(-1));

if ($cmd eq 'get') {
    my $method = 'GET';
    my $path;
    if (scalar(@ARGV) && $ARGV[0] !~ m/^\-/)  {
	$path = shift @ARGV;
    }
    my $res = call_method($path, $method, \@ARGV);
    die "implement me";
} elsif ($cmd eq 'set') {
    die "implement me";
} elsif ($cmd eq 'create') {
    die "implement me";
} elsif ($cmd eq 'delete') {
    die "implement me";
} elsif (my $class = $cli_class_handlers->{$cmd}) {
    $class->run_cli_handler();
} elsif ($cmd eq 'bashcomplete') {

    exit(0) if !(defined($ENV{COMP_LINE}) && defined($ENV{COMP_POINT}));

    my $cmdlist = join('|', keys %$cli_class_handlers);
    if ($ENV{COMP_LINE} =~ m/^(.*pveclient\s+($cmdlist)\s+)(.*)$/) {
	my $cmd = $2;
	my $class = $cli_class_handlers->{$cmd} || die "internal error";
	$ENV{COMP_LINE} = "pveclient $3";
	$ENV{COMP_POINT} = length($ENV{COMP_LINE});
	@ARGV = ('bashcomplete', 'pveclient', $ARGV[1], $ARGV[2]);

	$class->run_cli_handler();

    } else {

	my $cmdline = substr($ENV{COMP_LINE}, 0, $ENV{COMP_POINT});
	my ($bash_command, $cur, $prev) = @ARGV;
	$cmdline =~ s/$cur$//;

	my $args = PVE::Tools::split_args($cmdline);

	my @cmds = ('get', 'set', 'create', 'delete', keys %$cli_class_handlers);
	if (scalar(@$args) == 1) {
	    foreach my $p (@cmds) {
		print "$p\n" if $p =~ m/^$cur/;
	    }
	}
    }

} elsif ($cmd eq 'packagedepends') {
    # experimental code to print required perl packages
    my $packages = {};
    my $dir = Cwd::getcwd;

    foreach my $k (keys %INC) {
	my $file = abs_path($INC{$k});
	next if $file =~ m/^\Q$dir\E/;
	my $res = `dpkg -S '$file'`;
	if ($res && $res =~ m/^(\S+): $file$/) {
	    my $debian_package = $1;
	    $debian_package =~ s/:amd64$//;
	    $packages->{$debian_package} = 1;
	} else {
	    die "unable to find package for '$file'\n";
	}
    }
    print join("\n", sort(keys %$packages)) . "\n";
} else {
    print_usage();
}

exit(0);
