#!/usr/bin/perl

use strict;
use warnings;
use Cwd 'abs_path';
use lib '/usr/share/pve-client';
use lib '.';
use Data::Dumper;

use PVE::JSONSchema;
use PVE::CLIHandler;

use PVE::APIClient::LWP;
use PVE::APIClient::Helpers;
use PVE::APIClient::Commands::config;
use PVE::APIClient::Commands::remote;
use PVE::APIClient::Commands::list;
use PVE::APIClient::Commands::lxc;
use PVE::APIClient::Commands::help;

use JSON;

sub call_method {
    my ($path, $method, $args) = @_;

    die "missing API path\n" if !defined($path);

    my $info = PVE::APIClient::Helpers::lookup_api_method($path, $method);
    my $param = PVE::JSONSchema::get_options($info->{parameters}, $args);
    print Dumper($param);

    die "implement me";
}


my $cli_class_handlers = {
    list => 'PVE::APIClient::Commands::list',
    lxc => 'PVE::APIClient::Commands::lxc',
    remote => 'PVE::APIClient::Commands::remote',
    config => 'PVE::APIClient::Commands::config',
    help => 'PVE::APIClient::Commands::help',
};

my $cmd = shift;
if (!defined($cmd)) {
    PVE::APIClient::Commands::help->help({});
    exit(-1);
}

my $method_map = {
    create => 'POST',
    set => 'PUT',
    get => 'GET',
    delete => 'DELETE',
};

if (my $method = $method_map->{$cmd}) {
    my $path;
    if (scalar(@ARGV) && $ARGV[0] !~ m/^\-/)  {
	$path = shift @ARGV;
    }
    my $res = call_method($path, $method, \@ARGV);
    die "implement me";
} elsif (my $class = $cli_class_handlers->{$cmd}) {
    $class->run_cli_handler();
} elsif ($cmd eq 'bashcomplete') {

    exit(0) if !(defined($ENV{COMP_LINE}) && defined($ENV{COMP_POINT}));

    my $cmdlist = join('|', keys %$cli_class_handlers);
    if ($ENV{COMP_LINE} =~ m/^(.*pveclient\s+($cmdlist)\s+)(.*)$/) {
	my $cmd = $2;
	my $class = $cli_class_handlers->{$cmd} || die "internal error";

	if ($cmd eq 'list') { # simple commands
	    $ENV{COMP_LINE} = "pveclient $3";
	    $ENV{COMP_POINT} = length($ENV{COMP_LINE});
	    @ARGV = ('bashcomplete', 'pveclient', $ARGV[1], $ARGV[2]);
	} else {
	    $ENV{COMP_LINE} = "pveclient $3";
	    $ENV{COMP_POINT} = length($ENV{COMP_LINE});
	    @ARGV = ('bashcomplete', 'pveclient', $ARGV[1], $ARGV[2]);
	}
	$class->run_cli_handler();

    } else {

	my $cmdline = substr($ENV{COMP_LINE}, 0, $ENV{COMP_POINT});
	my ($bash_command, $cur, $prev) = @ARGV;
	$cmdline =~ s/\Q$cur\E$//;

	my $args = PVE::Tools::split_args($cmdline);

	my @cmds = (keys %$method_map, keys %$cli_class_handlers);
	if (scalar(@$args) == 1) {
	    foreach my $p (@cmds) {
		print "$p\n" if $p =~ m/^$cur/;
	    }
	} elsif (scalar(@$args) == 2) {
	    if (my $method = $method_map->{$args->[1]}) {
		PVE::APIClient::Helpers::complete_api_path($cur);
	    }
	} elsif (scalar(@$args) >= 3) {
	    my $path = $args->[2];
	    if (my $method = $method_map->{$args->[1]}) {
		if (my $info = PVE::APIClient::Helpers::lookup_api_method($path, $method, 1)) {
		    my $prop = $info->{parameters}->{properties};
		    PVE::APIClient::Helpers::complete_api_call_options($method, $prop, $prev, $cur, $args);
		}
	    }
	}
    }

} elsif ($cmd eq 'packagedepends') {
    # experimental code to print required perl packages
    my $packages = {};
    my $dir = Cwd::getcwd;

    foreach my $k (keys %INC) {
	my $file = abs_path($INC{$k});
	next if $file =~ m/^\Q$dir\E/;
	my $res = `dpkg -S '$file'`;
	if ($res && $res =~ m/^(\S+): $file$/) {
	    my $debian_package = $1;
	    $debian_package =~ s/:amd64$//;
	    $packages->{$debian_package} = 1;
	} else {
	    die "unable to find package for '$file'\n";
	}
    }
    print join("\n", sort(keys %$packages)) . "\n";
} else {
    PVE::APIClient::Commands::help->help({});
}

exit(0);
